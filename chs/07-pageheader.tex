% !TEX root = memman-ko.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \chapter{Pagination and headers} \label{chap:pagination}
\chapter{페이지 매김과 머릿글} \label{chap:pagination}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\section{Introduction}

%     The focus of this chapter is on marking the pages
% with signposts so that the reader can more readily navigate through
% the document.
본 단원은 페이지에 이정표를 표시함으로써 독자가 문서를 더 수월하게 찾을 수
있도록 하는데 집중한다.

% \section{Pagination and folios}
\section{페이지 매김과 폴리오}

%     Every page in a \ltx\ document is included in the
% pagination\index{pagination}. That is,
% there is a number associated with every page and this is the value of
% the \Icn{page} counter. This value\index{pagination!changing}
% can be changed at any time via either \cmd{\setcounter} or
% \cmd{\addtocounter}.
\ltx\ 문서의 모든 페이지는 페이지 매김\tidx{pagination,페이지 매김}된다.
즉, 각 페이지에는 번호가 할당되며 이것이 \Icn{page} 카운터의 값이다.
이 값\tidx{pagination!changing,페이지 매김!변경}은 \cmd{\setcounter}나
\cmd{\addtocounter}을 통해 언제든지 바꿀 수 있다.

\begin{syntax}
\cmd{\pagenumbering}\marg{rep} \\
\cmd{\pagenumbering*}\marg{rep} \\
\end{syntax}
\glossary(pagenumbering)%
  {\cs{pagenumbering}\marg{rep}}%
  {Resets the page number to 1, and causes the folios (page numbers) to be 
   printed using the \meta{rep}
   representation (e.g., \texttt{arabic}, \texttt{roman}, \ldots)}
\glossary(pagenumbering*)%
  {\cs{pagenumbering*}\marg{rep}}%
  {Like \cs{pagenumbering} except that the page number is not reset.}
% The macros \cmd{\pagenumbering} and \cmd{\pagenumbering*} cause
% the folios\index{folio}\index{folio!changing representation}
% to be printed using the
% counter representation\index{counter representation}
% \meta{rep} for the page number, where \meta{rep} can be one of:
% \pixcrep{Alph}, \pixcrep{alph}, \pixcrep{arabic}, \pixcrep{Roman} or
% \pixcrep{roman} for uppercase and lowercase letters, arabic numerals, and
% uppercase and lowercase Roman numerals,
% respectively.\index{alphabetic numbering}\index{roman numerals} As there
% are only 26~letters, \pixcrep{Alph} or \pixcrep{alph} can only be
% used for a limited number of pages. Effectively, the macros redefine
% \cmd{\thepage} to be \verb?\rep{page}?.
매크로 \cmd{\pagenumbering}과 \cmd{\pagenumbering*}은
폴리오(면 번호)\tidx{folio!changing representation,폴리오!표시 변경}가 카운터
표시\tidx{counter representation,카운터 표시} \meta{rep}를 통해 페이지 번호를
출력하도록 할 수 있는데, \meta{rep}는 \pixcrep{Alph}, \pixcrep{alph},
\pixcrep{arabic}, \pixcrep{Roman}, 혹은 \pixcrep{roman}을 사용해 각각 알파벳
대문자와 소문자, 아라비아 숫자, 대문자와 소문자 로마 숫자 중 하나가 될 수
있다.\tidx{alphabetic numbering,알파벳 번호}\tidx{roman numerals,로마 숫자}
알파벳에는 26개의 문자만 있기 때문에 \pixcrep{Alph} 혹은 \pixcrep{alph}는
한정된 수의 페이지에만 사용될 수 있다.
사실상 이 매크로들은 \cmd{\thepage}가 \verb|\rep{page}|가 되도록 재정의한다.

%     Additionally, the \cmd{\pagenumbering}\index{pagination!changing}
% command resets the \Icn{page} counter to one; the starred version does not
% change the counter.
%     It is usual to reset the page number back to one each time the style
% is changed, but sometimes it may be desirable to have a continuous sequence
% of numbers irrespective of their displayed form, which is where
% the starred version comes in handy.
추가적으로, \cmd{\pagenumbering}\tidx{pagination!changing,페이지 매김!변경}
명령은 \Icn{page} 카운터를 1로 초기화하며, 별표 붙은 것은 카운터를 변경하지
않는다.
양식이 바뀔 때마다 페이지 번호를 다시 1로 초기화하는 것이 일반적이지만, 간혹
보여지는 형식과는 상관없이 일련의 숫자를 가지도록 해야할 때에는 별표 붙은 버전이
유용하다.

\begin{syntax}
\cmd{\savepagenumber} \\
\cmd{\restorepagenumber} \\
\end{syntax}
\glossary(savepagenumber)%
  {\cs{savepagenumber}}%
  {Saves the current page number.}
\glossary(restorepagenumber)%
  {\cs{restorepagenumber}}%
  {Sets the page number to that saved by the most recent \cs{savepagenumber}.}
% The macro \cmd{\savepagenumber} saves the current page number, and the
% macro \cmd{\restorepagenumber} sets the page number to the saved value.
% This pair of commands may be used to apparently
% interrupt\index{pagination!interrupt} the pagination.
% For example, perhaps some full page illustrations\index{illustration}
% will be electronically tipped in\index{tip in} to the document and
% pagination is not required for these.
% This could be done along the lines of:
매크로 \cmd{\savepagenumber}는 현재 페이지 번호를 저장하며, 매크로
\cmd{\restorepagenumber}는 페이지 번호를 저장된 것으로 설정한다.
이 한 쌍의 명령은 페이지 매김을 외관상
중단\tidx{pagination!interrupt,페이지 매김!중단}할 때 사용될 수 있다.
예를 들어, 전면 삽화\tidx{illustration,삽화}가 전자 문서에 끼워 넣어질 수
있는데 이 때는 페이지 매김이 불필요하다.
이는 다음과 같이 할 수 있다.
\begin{lcode}
\clearpage          % get onto next page
\savepagenumber     % save the page number
\pagestyle{empty}   % no headers or footers
%% insert the illustrations
\clearpage
\pagestyle{...}
\restorepagenumber
...
\end{lcode}
% If you try this sort of thing, you may have to adjust the restored page
% number by one.
여러분이 이런 비슷한 작업을 한다면, 복원된 페이지 번호를 1 정도 조절해야 할
수도 있다.
\begin{lcode}
\restorepagenumber
% perhaps \addtocounter{page}{1} or \addtocounter{page}{-1}
\end{lcode}
% Depending on the timing of the \cs{...pagenumber} commands and \tx's
% decisions on page breaking, this may or may not be necessary.
\cs{...pagenumber} 명령의 실행 시점과 페이지 나눔에 대한 \tx의 결정에 따라 이런
조정이 필요할 수도, 그렇지 않을 수도 있다.



% \section{Page styles} \label{sec:pagestyles}
\section{페이지 양식} \label{sec:pagestyles}

% \index{pagestyle!specifying|(}
\tidx{페이지 양식!지정|(}

%     The class provides a selection of pagestyles that you can use and if
% they don't suit, then there are means to define your own.
본 클래스는 여러분이 쓸 수 있는 페이지 양식 모음을 제공하며, 여러분 마음에 들지
않는다면 직접 정의할 수도 있다.

    % These facilities were inspired by the \Lpack{fancyhdr}
% package~\cite{FANCYHDR}, although the command set is different.
이 기능들은 \Lpack{fancyhdr} 패키지~\cite{FANCYHDR}에 영향을 받았으나,
명령어들은 다르다.

%     The standard classes provide for a footer\index{footer} and
% header\index{header} for odd and even
% pages. Thus there are four elements to be specified for a pagestyle.
% This class partitions the headers\index{header} and footers\index{footer}
% into left, center and right
% portions, so that overall there is a total of 12 elements that have
% to be specified
% for a pagestyle. You may find, though, that one of the built in pagestyles
% meets your needs so you don't have to worry about all these specifications.
표준 클래스들은 홀수와 짝수 페이지에 대한 바닥글\tidx{footer,바닥글}과
머릿글\tidx{header,머릿글}을 제공한다.
따라서 페이지 양식에 대한 네 요소를 지정할 수 있다.
이 클래스는 머릿글\tidx{header,머릿글}과 바닥글\tidx{footer,바닥글}을 왼쪽,
가운데, 그리고 오른쪽 부분으로 나누어 페이지 양식을 위해 총 12개의 요소를
지정해야 한다.
그러나 내장된 페이지 양식이 충분할 경우에는 이 모든 설정에 대해서 걱정하지
않아도 된다.

\begin{syntax}
\cmd{\pagestyle}\marg{style} \\
\cmd{\thispagestyle}\marg{style} \\
\end{syntax}
\glossary(pagestyle)%
  {\cs{pagestyle}\marg{style}}%
  {Sets the current pagestyle to \meta{style}.}
\glossary(thispagestyle)%
  {\cs{thispagestyle}\marg{style}}%
  {Sets the pagestyle to \meta{style} for the current page only.}
%    \cmd{\pagestyle} sets the current pagestyle to \meta{style}, where
% \meta{style} is a word containing only letters. On a particular
% page \cmd{\thispagestyle} can be used to override the current pagestyle for
% the one page.
\cmd{\pagestyle}은 현재 페이지 양식을 \meta{style}로 정하는데, \meta{style}은
문자로만 구성된 단어이다.
특정 페이지에서는 \cmd{\thispagestyle}을 사용해 현재 페이지 양식을 해당 쪽만
덮어쓸 수 있다.

%     Some of the class' commands automatically call \cmd{\thispagestyle}.
% For example:
클래스의 일부 명령들은 자동으로 \cmd{\thispagestyle}을 부른다.
예를 들어,
% \begin{itemize}
% \item the \Ie{titlingpage} environment calls
%       \begin{lcode}
% \thispagestyle{titlingpagestyle}
%       \end{lcode}
% \item if \cmd{\cleardoublepage} will result in an empty verso page it calls
%       \begin{lcode}
% \thispagestyle{cleared}
%       \end{lcode}
%       for the empty page.
% \end{itemize}
\begin{itemize}
\item \Ie{titlingpage} 환경은
      \begin{lcode}
\thispagestyle{titlingpagestyle}
      \end{lcode} 
      을 부른다.
\item 만약 \cmd{\cleardoublepage} 이 빈 왼쪽 면을 만든다면
      \begin{lcode}
\thispagestyle{cleared}
      \end{lcode}
      를 해당 빈 페이지에서 부른다.
\end{itemize}
% For reference, the full list is given in \tref{tab:callthispagestyle}.
참고로, 전체 목록은 \tref{tab:callthispagestyle}에 주어져 있다.

\PWnote{2009/07/26}{Added the simple pagestyle}
    % The page styles provided by the class\index{pagestyle!class} are:
본 클래스\tidx{pagestyle!class,페이지 양식!클래스}에 의해 제공되는 페이지
양식은 다음과 같다.
% \begin{plainlist}
% \item[\pstyle{empty}] The headers\index{header} and footers\index{footer} are empty.
% \item[\pstyle{plain}] The header\index{header} is empty and the folio\index{folio} (page number)
%      is centered at the bottom of the page.
% \item[\pstyle{headings}] The footer\index{footer} is empty. The header\index{header} contains
%      the folio\index{folio} at the outer side of the page; on verso
%      pages the chapter name, number and title, in slanted uppercase is
%      set at the spine margin and on recto pages the section number
%      and uppercase title is set by the spine margin.
% \item[\pstyle{myheadings}] Like the \pstyle{headings} style the footer
%      is empty. You have to specify what is to go in the headers\index{header}.
% \item[\pstyle{simple}] The footer\index{footer} is empty and the
%      header\index{header} contains the folio\index{folio} (page number)
%      at the outer side of the page. It is like the \pstyle{headings}
%      style but without any title texts.
% \item[\pstyle{ruled}] The footer\index{footer} contains the
%      folio\index{folio} at the outside. The header\index{header}
%      on verso pages contains the chapter number and title in small caps
%      at the outside; on recto pges the section title is typeset at the
%      outside using the normal font. A line is drawn
     % underneath the header\index{header}.
% \item[\pstyle{Ruled}] This is like the \pstyle{ruled} style except that
%      the headers\index{header} and footers\index{footer} extend into
%      the \foredge\ margin\index{margin!foredge?\foredge}.
% \item[\pstyle{companion}] This is a copy of the pagestyle in the
%      \textit{Companion} series (e.g., see~\cite{COMPANION}). It is
%      similar to the \pstyle{Ruled} style in that the header has a rule which
%      extends to the outer edge of the marginal notes. The folios are set
%      in bold at the outer ends of the header. The chapter title is set in
%      a bold font flushright in the verso headers, and the section number
%      and title, again in bold, flushleft in the recto headers\index{header}.
%      There are no footers\index{footer}.
% \item[\pstyle{book}] This is the same as the \pstyle{plain} pagestyle.
% \item[\pstyle{chapter}]  This is the same as the \pstyle{plain} pagestyle.
% \item[\pstyle{cleared}]  This is the same as the \pstyle{empty} pagestyle.
% \item[\pstyle{part}] This is the same as the \pstyle{plain} pagestyle.
% \item[\pstyle{title}]   This is the same as the \pstyle{plain} pagestyle.
% \item[\pstyle{titlingpage}] This is the same as the \pstyle{empty} pagestyle.
% \end{plainlist}
\begin{plainlist}
\item[\pstyle{empty}] 머릿글\tidx{header,머릿글}과 바닥글\tidx{footer,바닥글}이
  비어 있다.
\item[\pstyle{plain}] 머릿글\tidx{header,머릿글}이 비어 있고
     폴리오\tidx{folio,폴리오} (페이지 번호)는 페이지 하단 중앙에 놓인다.
\item[\pstyle{headings}] 바닥글\tidx{footer,바닥글}이 비어 있다.
     머릿글\tidx{header,머릿글}은 폴리오\tidx{folio,폴리오}를 페이지 바깥쪽에
     둔다. 왼쪽 페이지에는 장 이름, 번호와 제목이 기울어진 대문자로 책 등
     여백에 놓이고, 오른쪽 페이지에는 절 이름과 대문자 제목이 책 등 여백에
     놓인다.
\item[\pstyle{myheadings}] \pstyle{heading} 양식처럼 바닥글이 비어 있다.
     여러분이 머릿글\tidx{header,머릿글}에 들어갈 내용을 지정해야 한다.
\item[\pstyle{simple}] 바닥글\tidx{footer,바닥글}이 비어 있고
     머릿글\tidx{header,머릿글}은 폴리오\tidx{folio,폴리오} (페이지 번호)를
     페이지 바깥쪽에 놓는다.
     이는 \pstyle{headings} 양식과 비슷하지만 제목 문구가 없다.
\item[\pstyle{ruled}] 바닥글\tidx{footer,바닥글}이
     폴리오\tidx{folio,폴리오}를 바깥쪽에 놓는다.
     왼쪽 페이지의 머릿글\tidx{header,머릿글}과 제목은 바깥쪽에 small caps로,
     오른족 페이지에서는 절 제목이 normal 폰트로 바깥쪽에 식자된다.
     머릿글\tidx{header,머릿글} 밑에 선이 그려진다.
\item[\pstyle{Ruled}] 이는 머릿글\tidx{header,머릿글}과
     바닥글\tidx{footer,바닥글}이 재단
     여백\tidx{margin!foredge?\foredge,여백!재단 여백}으로 확장된다는 것을
     제외하고는 \pstyle{ruled} 양식과 같다.
\item[\pstyle{companion}] 이는 \textit{Companion} 시리즈의 페이지 양식
     사본이다 (예시로는 \cite{COMPANION}을 보라).
     이는 머릿글이 여백 주석의 바깥쪽 모서리까지 이어지는 선을 가지고 있다는
     점에서 \pstyle{Ruled}와 비슷하다.
     폴리오는 왼쪽 페이지 머릿글에 볼트체 오른쪽 정렬되어 있으며, 절 이름과
     제목이 오른쪽 머릿글\tidx{header,머릿글}에 다시 볼드체로 왼쪽 정렬되어
     있다.
     바닥글\tidx{footer,바닥글}은 없다.
\item[\pstyle{book}] 이는 \pstyle{plain} 페이지 양식과 같다.
\item[\pstyle{chapter}]  이는 \pstyle{plain} 페이지 양식과 같다.
\item[\pstyle{cleared}]  이는 \pstyle{empty} 페이지 양식과 같다.
\item[\pstyle{part}] 이는 \pstyle{plain} 페이지 양식과 같다.
\item[\pstyle{title}] 이는 \pstyle{plain} 페이지 양식과 같다.
\item[\pstyle{titlingpage}] 이는 \pstyle{empty} 페이지 양식과 같다.
\end{plainlist}

\begin{table}
\centering
\caption{\protect\cs{thispagestyle}의 사용}\label{tab:callthispagestyle}
\begin{tabular}{l !{\qquad} l} \toprule
사용된 곳 & 양식 \\ \midrule
\cmd{\book}    & \pstyle{book} \\
\cmd{\chapter} & \pstyle{chapter} \\
\cmd{\cleardoublepage} & \pstyle{cleared} \\
\cmd{\cleartorecto} & \pstyle{cleared} \\
\cmd{\cleartoverso} & \pstyle{cleared} \\
\cmd{\epigraphhead} & \pstyle{epigraph} \\
\cmd{\listoffigures} & \pstyle{chapter} \\
\cmd{\listoftables} & \pstyle{chapter} \\
\cmd{\maketitle} & \pstyle{title} \\
\cmd{\part}      & \pstyle{part} \\
\cmd{\tableofcontents} & \pstyle{chapter} \\
\Ie{thebibliography} & \pstyle{chapter} \\
\Ie{theindex} & \pstyle{chapter} \\
\Ie{titlingpage} & \pstyle{titlingpage} \\
\bottomrule
\end{tabular}
\end{table}

\begin{syntax}
\cmd{\uppercaseheads} \cmd{\nouppercaseheads}  \\
\end{syntax}
\glossary(uppercaseheads)%
  {\cs{uppercaseheads}}%
  {Set the titles in the headings pagestyle in Uppercase.}
\glossary(nouppercaseheads)%
  {\cs{nouppercaseheads}}%
  {Do not uppercase the titles in the headings.}
%     Following the declaration \cmd{\nouppercaseheads} the titles in the
% \pstyle{headings} pagestyle will not be automatically uppercased. The default
% is \cmd{\uppercaseheads} which specifies that the titles are to be
% automatically uppercased.
\pstyle{headings}에서 \cmd{\nouppercaseheads} 정의에 뒤따르는 제목은 자동으로
대문자로 바뀌지 않을 것다.
기본은 \cmd{\uppercaseheads}로, 제목은 자동으로 대문자 처리되도록 지정하는
것이다.

% \textbf{Change 2012:} The upper casing macro used by \cmd{\uppercaseheads} has
% been changed into \cmd{\MakeTextUppercase} such that the upper casing
% does not touch math, references or citations.
\textbf{2012 수정:} \cmd{uppercaseheads}에 사용되는 대문자화 매크로는
\cmd{MakeTextUppercase}로 변경되어 수식, 참조나 인용을 건드리지 않게 되었다.

%     For the \pstyle{myheadings} pagestyle above, you have to define your own
% titles to go into the header\index{header}. Each sectioning command,
% say \cs{sec},
% calls a macro called \cs{secmark}. A pagestyle usually defines this command
% so that it picks up the title, and perhaps the number, of the \cs{sec}. The
% pagestyle can then use the information for its own purposes.
위의 \pstyle{myheadings}을 위해서, 여러분은 머릿글\tidx{haeder,머릿글}에 들어갈
제목을 직접 정의해야 한다.
\cs{sec}과 같은 장절 명령은 각각 \cs{secmark}라는 매크로를 부른다.
페이지 양식은 보통 이 명령어를 정의해 \cs{sec}의 제목이나 번호를 추출한다.
페이지 양식은 이후 이 정보를 용도에 맞게 사용할 수 있다.

\begin{syntax}
\cmd{\markboth}\marg{left}\marg{right} \\
\cmd{\markright}\marg{right} \\
\end{syntax}
\glossary(markboth)%
  {\cs{markboth}\marg{left}\marg{right}}%
  {Sets values of two markers to \meta{left} and \meta{right} respectively
   (see \cs{leftmark} and \cs{rightmark}).}
\glossary(markright)%
  {\cs{markright}\marg{right}}%
  {Sets value of one marker to \meta{right} (see \cs{rightmark}).}
%     \cmd{\markboth} sets the values of two \emph{markers}\index{markers}
% to \meta{left} and \meta{right} respectively, at the point in the text
% where it is called. Similarly, \cmd{\markright} sets the value of a
% marker to \meta{right}.
\cmd{\markboth}는 이 명령이 불리운 자리에서 두 \emph{표지}\tidx{markers,표지}의
값을 \meta{left}와 \meta{right}에 설정한다.

\begin{syntax}
\cmd{\leftmark} \cmd{\rightmark} \\
\end{syntax}
\glossary(leftmark)%
  {\cs{leftmark}}%
  {Contains the value of the \meta{left} argument of the last \cs{markboth}.}
\glossary(rightmark)%
  {\cs{rightmark}}%
  {Contains the value of the \meta{right} argument of the first \cs{markboth}
   or \cs{markright} on the page; if there is none then the value of the most
   recent \meta{right} argument.}
% The macro \cmd{\leftmark} contains the value of the \meta{left} argument
% of the \emph{last} \cmd{\markboth} on the page. The macro \cmd{\rightmark}
% contains the value of the \meta{right} argument of the \emph{first}
% \cmd{\markboth} or \cmd{\markright} on the page, or if there is not one it
% contains the value of the most recent \meta{right} argument.
매크로 \cmd{\leftmark}는 쪽에서 \emph{마지막} \cmd{\markboth} 명령의
\meta{left} 인자의 값을 담는다.
매크로 \cmd{\rightmark}는 페이지의 \emph{처음} \cmd{\markboth}나
\cmd{\markright}의 \meta{right} 인자의 값을 담거나, 해당 명령이 없다면 가장
최근 것의 \meta{right} 인자의 값을 담는다.

%     A pagestyle can define the \cs{secmark} commands in terms of
% \cmd{\markboth} or \cmd{\markright}, and then use \cmd{\leftmark} and/or
% \cmd{\rightmark} in the headers\index{header} or footers\index{footer}.
% I'll show examples of how this
% works later, and this is often how the \pstyle{myheadings} style gets
% implemented.
페이지 양식은 \cmd{\markboth}와 \cmd{\markright}으로 \cmd{secmark} 명령어를
정의할 수 있고, \cmd{\leftmark}와(혹은) \cmd{\rightmark}를
머릿글\tidx{header,머릿글}이나 바닥글\tidx{footer,바닥글}에서 쓴다.
이것이 어떻게 되는 것인지 나중에 예시를 보일 것이며, 이는 \pstyle{myheadings}
양식이 보통 구현되는 방식이다.

%     All the division commands include a macro that you can define to set
% marks related to that heading. Other commands also include macros that
% you can redefine for setting marks.
모든 장절 구획 명령은 해당 머릿글과 관련해 여러분이 정의할 수 있는 매크로를
포함하고 있다.
다른 명령어들도 여러분이 재정의할 수 있는 표지 설정을 포함한다.

\begin{table}
\centering
% \caption{Mark macros for page headers} \label{tab:markmacros}
\caption{페이지 머릿글에 대한 표지 매크로} \label{tab:markmacros}
\begin{tabular}{ll} \toprule
% Main macro & default mark definition \\ \midrule
주 매크로 & 기본 표지 정의 \\ \midrule
\cs{book(*)}            & \verb?\newcommand*{\bookpagemark}[1]{}? \\
\cs{part(*)}            & \verb?\newcommand*{\partmark}[1]{}? \\
\cs{chapter(*)}         & \verb?\newcommand*{\chaptermark}[1]{}? \\
\cs{section(*)}         & \verb?\newcommand*{\sectionmark}[1]{}? \\
\cs{subsection(*)}      & \verb?\newcommand*{\subsectionmark}[1]{}? \\
\cs{subsubsection(*)}   & \verb?\newcommand*{\subsubsectionmark}[1]{}? \\
\cs{paragraph(*)}       & \verb?\newcommand*{\paragraphmark}[1]{}? \\
\cs{subparagraph(*)}    & \verb?\newcommand*{\subparagraphmark}[1]{}? \\
\cs{tableofcontents(*)} & \verb?\newcommand*{\tocmark}[1]{}? \\
\cs{listoffigures(*)}   & \verb?\newcommand*{\lofmark}[1]{}? \\
\cs{listoftables(*)}    & \verb?\newcommand*{\lotmark}[1]{}? \\
\cs{thebibliography}    & \verb?\newcommand*{\bibmark}{}? \\
\cs{theindex}           & \verb?\newcommand*{\indexmark}{}? \\
\cs{theglossary}        & \verb?\newcommand*{\glossarymark}{}? \\
\cs{PoemTitle}          & \verb?\newcommand*{\poemtitlemark}[1]{}? \\
\cs{PoemTitle*}         & \verb?\newcommand*{\poemtitlestarmark}[1]{}? \\
\bottomrule
\end{tabular}
\end{table}

% The \cs{...mark} commands are listed in \tref{tab:markmacros}. When they are
% called by the relevant main macro, those that take an argument are called with
% the `title' as the argument's value. For example, the \cmd{\chapter} macro
% calls \cmd{\chaptermark} with the value of the title specified as being
% for the header.
\cs{...mark} 명령어들이 \tref{tab:markmacros}에 나열되어 있다. 이들이 관련된 주
매크로에 의해 불리우면, `title'을 인자의 값으로 취한다.
예를 들어, \cmd{\chapter} 매크로는 \cmd{\chaptermark}이 머릿글이 되도록 제목의
값을 지정하여 부른다.

% Please remember that the macros listed in \tref{tab:markmacros} are
% `provider' macros, i.e. they provide information for \cmd{\leftmark}
% and \cmd{\rightmark} for you to use later on. To gain access to the
% section title, you do \emph{not} use \cmd{\sectionmark} in the header
% or footer. It is a macro that provides information, but you need to
% use \cmd{\leftmark} or \cmd{\rightmark} to access depending on how you
% have defined \cmd{\sectionmark}.
부디 \tref{tab:markmacros}에 나열된 매크로들이 `제공자' 매크임을 잊지 말아달라.
즉, 이들은 여러분이 \cmd{\leftmark}와 \cmd{\rightmark}의 정보를 나중에 쓸 수
있도록 제공해 준다.
절 제목에 접근하기 위해서 \cmd{\sectionmark}를 머릿글이나 바닥글에 사용하면
\emph{안 된다}.
매크로가 정보를 제공해주지만, 여러분은 \cmd{\sectionmark}를 어떻게 정의했는지에
따라서 \cmd{\leftmark} 혹은 \cmd{\rightmark}를 사용해 접근해야 한다.


% \section{Making headers and footers}
\section{머릿글과 바닥글 만들기}

%     As mentioned, the class provides for left, center, and right slots in
% even and odd headers\index{header} and footers\index{footer}.
% This section describes how you can make
% your own pagestyle using these 12 slots. The 6 slots for a page
% are diagrammed in \fref{lay:header}.
언급하였듯이, 이 클래스는 짝수와 홀수 머릿글\tidx{header,머릿글}과
바닥글\tidx{footer,바닥글}의 왼쪽, 가운데, 그리고 오른쪽 영역을 제공한다.
본 절은 여러분이 이 12개의 영역을 사용해 직접 페이지 양식을 만드는 방법을
설명한다.
페이지의 6개 영역은 \fref{lay:header}에 도표로 나타나 있다.

\begin{figure}
\setlayoutscale{1}
\centering
\headerfooterdiagram
% \caption{Header and footer slots} \label{lay:header}
\caption{머릿글과 바닥글 영역}\label{lay:header}
\end{figure}

%     The class itself uses the commands from this section. For example,
% the \pstyle{plain} pagestyle is defined as
이 클래스 자체도 이 절의 명령들을 사용한다.
예를 들어, \pstyle{plain} 페이지 양식은 다음과 같이 정의되어 있다.
\begin{lcode}
\makepagestyle{plain}
  \makeevenfoot{plain}{}{\thepage}{}
  \makeoddfoot{plain}{}{\thepage}{}
\end{lcode}
% which centers the page number at the bottom of the page.
이는 페이지 번호를 페이지 하단에 중앙 정렬한다.


\begin{syntax}
\cmd{\makepagestyle}\marg{style} \\
\cmd{\aliaspagestyle}\marg{alias}\marg{original} \\
\cmd{\copypagestyle}\marg{copy}\marg{original}\\
\end{syntax}
\glossary(makepagestyle)%
  {\cs{makepagestyle}\marg{style}}%
  {Used to define a pagestyle \meta{style}.}
\glossary(aliaspagestyle)%
  {\cs{aliaspagestyle}\marg{alias}{original}}%
  {Defines the \meta{alias} pagestyle to be the same as the \meta{original}
  pagestyle.}
\glossary(copypagestyle)%
  {\cs{copypagestyle}\marg{copy}{original}}%
  {Creates a new pagestyle called \meta{copy} using the \meta{original}
   pagestyle specification.}

% The command \cmd{\makepagestyle} specifies a pagestyle \meta{style} which
% is initially equivalent to the \pstyle{empty} pagestyle. On the other hand,
% \cmd{\aliaspagestyle} defines the \meta{alias} pagestyle to be the same as
% the \meta{original} pagestyle. As an example of the latter, the class includes
% the code
\cmd{\makepagestyle} 명령은 \meta{style} 페이지 양식을 지정하는데, 이는 초기에
\pstyle{empty} 페이지 양식과 동일하다.
반면, \cmd{\aliaspagestyle}은 \meta{alias} 페이지 양식을 \meta{original} 페이지
양식과 같도록 정의한다.
후자의 예시로 본 클래스가 다음 코드를 포함한다.
\begin{lcode}
\aliaspagestyle{part}{plain}
\aliaspagestyle{chapter}{plain}
\aliaspagestyle{cleared}{empty}
\end{lcode}
% The \cmd{\copypagestyle} command creates a new pagestyle called \meta{copy}
% using the \meta{original} pagestyle specification.
\cmd{\copypagestyle} 명령은 \meta{original} 페이지 양식 설정으로 \meta{copy}라는
새로운 페이지 양식을 생성한다.

%     If an alias and a copy pagestyle are created based on the same
% \meta{original} and later the \meta{original} is modified,
% the alias and copy behave differently.
% The appearance of the alias pagestyle will continue to match the
% modified \meta{original} but the copy pagestyle is unaffected by any change
% to the \meta{original}. You cannot modify an alias pagestyle but you can
% modify a copy pagestyle.
만약 참조(alias)와 사본(copy) 페이지 양식이 \meta{original}을 토대로 생성된 후,
\meta{original}이 수정되었다면, 참조와 사본은 다르게 행동한다.
참조 페이지 양식은 수정된 \meta{original}과 여전히 일치하지만 사본 페이지
양식은 \meta{original}의 어떠한 변경에도 영향을 받지 않는다.
여러분은 참조 페이지 양식을 수정할 수 없지만 사본 페이지 양식은 수정할 수 있다.

\begin{syntax}
\cmd{\makeevenhead}\marg{style}\marg{left}\marg{center}\marg{right} \\
\cmd{\makeoddhead}\marg{style}\marg{left}\marg{center}\marg{right} \\
\cmd{\makeevenfoot}\marg{style}\marg{left}\marg{center}\marg{right} \\
\cmd{\makeoddfoot}\marg{style}\marg{left}\marg{center}\marg{right} \\
\end{syntax}
\glossary(makeevenhead)%
  {\cs{makeevenhead}\marg{style}\marg{left}\marg{center}\marg{right}}%
  {Defines the \meta{left}, \meta{center} and \meta{right} parts of the
   even (verso) page header of the \meta{style} pagetstyle.}
\glossary(makeoddhead)%
  {\cs{makeoddhead}\marg{style}\marg{left}\marg{center}\marg{right}}%
  {Defines the \meta{left}, \meta{center} and \meta{right} parts of the
   odd (recto) page header of the \meta{style} pagetstyle.}
\glossary(makeevenfoot)%
  {\cs{makeevenfoot}\marg{style}\marg{left}\marg{center}\marg{right}}%
  {Defines the \meta{left}, \meta{center} and \meta{right} parts of the
   even (verso) page footer of the \meta{style} pagetstyle.}
\glossary(makeoddfoot)%
  {\cs{makeoddfoot}\marg{style}\marg{left}\marg{center}\marg{right}}%
  {Defines the \meta{left}, \meta{center} and \meta{right} parts of the
   odd (recto) page footer of the \meta{style} pagetstyle.}
% The macro \cmd{\makeevenhead} defines the \meta{left}, \meta{center}, and
% \meta{right} portions of the \meta{style} pagestyle header\index{header}
% for even numbered (verso) pages.
% Similarly \cmd{\makeoddhead}, \cmd{\makeevenfoot}, and
% \cmd{\makeoddfoot} define the \meta{left}, \meta{center} and \meta{right}
% portions of the \meta{style} header\index{header} for odd numbered
% (recto) pages, and the footers\index{footer} for verso and recto pages.
% These commands for \meta{style}
% should be used after the corresponding \cmd{\makepagestyle} for \meta{style}.
매크로 \cmd{\makeevenhead}는 짝수 페이지에 대해 \meta{left}, \meta{center},
그리고 \meta{right} 영역의 \meta{style} 페이지 양식
머릿글\tidx{header,머릿글}을 정의한다.
비슷하게 \cmd{\makeoddhead}, \cmd{\makeevenfoot}, 그리고 \cmd{\makeoddfoot}은
홀수 페이지의 \meta{left}, \meta{center}, \meta{right} 영역 \meta{style}
머릿글\tidx{header,머릿글}을 정의하고, 홀수와 짝수 페이지의
바닥글\tidx{footer,바닥글}을 정의한다.
이 \meta{style} 명령들은 대응되는 \meta{style}의 \cmd{\makepagestyle} 이후에
사용되어야 한다.

\begin{syntax}
\cmd{\makerunningwidth}\marg{style}\oarg{footwidth}\marg{headwidth} \\
\lnc{\headwidth} \\
\end{syntax}
\glossary(makerunningwidth)%
  {\cs{makerunningwidth}\marg{style}\oarg{footwidth}\marg{headwidth}}%
  {Sets the width of the \meta{style} pagestyle headers to \meta{headwidth}.
   The footers are set to \meta{headwidth}, or \meta{footwidth} if it
   is given.}
\glossary(headwidth)%
  {\cs{headwith}}%
  {A (scratch) length normally used in the definition of headers and footers.}
% The macro \cmd{\makerunningwidth} sets the widths of the \meta{style}
% pagestyle headers\index{header} and footers\index{footer}. The header
% width is set to \meta{headwidth}. If the optional \meta{footwidth} is
% present, then the footer width is set to that, otherwise to \meta{headwidth}.
% The header width is stored as the length \cs{\meta{style}headrunwidth}
% and the footer width as \cs{\meta{style}footrunwidth}.
매크로 \cmd{\makerunningwidth}는 \meta{style} 페이지 양식의
머릿글\tidx{header,머릿글}과 바닥글\tidx{footer,바닥글}의 너비를 지정한다.
머릿글의 너비는 \meta{headwidth}로 설정된다.
만약 \meta{footwidth}가 선택적으로 존재한다면, 바닥글 너비는 이 값으로 설정될
것이며 그렇지 않을 경우에는 \meta{headwidth}로 설정된다.
머릿글 너비는 길이 \cs{\meta{style}{headrunwidth}}로, 바닥글 너비는
\cs{\meta{style}footrunwidth}에 저장된다.

% The \cmd{\makepagestyle} initialises the widths to be the textwidth,
% so the macro need only be used if some
% other width is desired. The length \lnc{\headwidth} is provided as a
% (scratch) length that may be used for headers\index{header} or
% footers\index{footer}, or any other purpose.
\cmd{\makepagestyle}은 너비를 본문 너비로 설정하므로, 이 매크로는 다른 너비
값이 필요할 때만 사용된다.
길이 \lnc{\headwidth}는 머릿글\tidx{header,머릿글}이나
바닥글\tidx{footer,바닥글}, 혹은 다른 목적으로 사용될 수 있도록 (임시) 길이로
제공된다.

\begin{syntax}
\cmd{\makeheadrule}\marg{style}\marg{width}\marg{thickness} \\
\cmd{\makefootrule}\marg{style}\marg{width}\marg{thickness}\marg{skip} \\
\cmd{\makeheadfootruleprefix}\marg{style}\marg{for headrule}\marg{for footrule}\\
\end{syntax}
\glossary(makeheadrule)%
  {\cs{makeheadrule}\marg{style}\marg{width}\marg{thickness}}%
  {Specifies the \meta{width} and \meta{thickness} of the rule drawn below the
   headers of the \meta{style} pagestyle.}%
\glossary(makefootrule)%
  {\cs{makefootrule}\marg{style}\marg{width}\marg{thickness}\marg{skip}}%
  {Specifies the \meta{width} and \meta{thickness} of the rule drawn 
  \meta{skip} (see \cs{footskip}) above the footers of the
  \meta{style} pagestyle.}% 
\glossary(makeheadfootruleprefix)
{\cs{makeheadfootruleprefix}\marg{style}\marg{for headrule}\marg{for
    footrule}}%
{Can be used to add alternative colors to the head/foot rule}%
% A header\index{header} may have a rule drawn between it and the top of
% the typeblock\index{typeblock}, and similarly a rule may be drawn
% between the bottom of the typeblock\index{typeblock} and the
% footer\index{footer}.
% The \cmd{\makeheadrule} macro specifies the \meta{width}
% and \meta{thickness} of the rule below the \meta{style} pagestyle
% header\index{header}, and the \cmd{\makefootrule} does the same for
% the rule above the footer\index{footer}; the
% additional \meta{skip} argument is a distance that specifies the vertical
% positioning of the foot rule (see \cmd{\footruleskip}).
% The \cmd{\makepagestyle} macro initialises the \meta{width} to the
% \lnc{\textwidth} and the \meta{thickness} to 0pt, so by default no rules
% are visible. The macro \cmd{\makeheadfootruleprefix} is intended for
% adding alternative colors to the head/foot rules, e.g.
머릿글\tidx{header,머릿글}은 조판 영역\tidx{typeblock,조판 영역}의 위와 자신
사이에 괘선이 그려질 수 있으며, 비슷하게 조판 영역\tidx{typeblock,조판 영역}
아래와 바닥글\tidx{footer,바닥글} 위에 괘선이 그려질 수 있다.
\cmd{\makeheadrule} 매크로는 \meta{style} 페이지 양식
머릿글\tidx{header,머릿글} 아래 괘선의 \meta{width}와 \meta{thickness}를
지정한다.
추가적 인자 \meta{skip}은 바닥 괘선의 세로 위치를 지정하는 길이이다
(\cmd{\footruleskip}을 보라).
\cmd{\makepagestyle} 매크로는 \meta{width}를 \lnc{\textwidth}로 초기화하고
\meta{thickness}를 0pt로 초기화해서, 기본적으로는 괘선이 보이지 않는다.
매크로 \cmd{\makeheadfootruleprefix}는 머리/바닥 괘선의 대체 색상을 추가할 수
있도록 하는데, 예를 들어 다음과 같다.
\begin{lcode}
  \makeheadfootruleprefix{mystyle}{\color{red}}{\color{blue}}
\end{lcode}


\begin{syntax}
\lnc{\normalrulethickness} \\
\end{syntax}
\glossary(normalrulethickness)%
  {\cs{normalrulethickness}}%
  {The normal thickness of a visible rule (default 0.4pt).}
% \lnc{\normalrulethickness} is the normal\index{rule!thickness}
% thickness of a visible rule, by
% default 0.4pt. It can be changed using \cmd{\setlength}, although I suggest
% that you do not unless perhaps when using at least the \Lopt{14pt} class
% option.
\lnc{\normalrulethickness}는 보이는 괘선의 기본\tidx{rule!thickness,선!두께}
두께로, 0.4pt이다.
이는 \cmd{\setlength}를 통해 바꿀 수 있지만, 필자는 여러분이 적어도 \Lopt{14pt}
클래스 옵션을 사용하지 않는 이상 그렇게 하지 않기를 권장한다.

\begin{syntax}
\cmd{\footruleheight} \\
\cmd{\footruleskip} \\
\end{syntax}
\glossary(footruleheight)%
  {\cs{footruleheight}}%
  {Macro specifying the height of a normal rule above a footer.}
\glossary(footruleskip)%
  {\cs{footruleskip}}%
  {Macro specifying a distance sufficient to ensure that a rule above a footer
   will lie in the space between the footer and the typeblock.}
% The macro \cmd{\footruleheight} is the height of a normal
% rule above a footer\index{footer} (default zero).
% \cmd{\footruleskip} is a distance
% sufficient to ensure that a foot rule will be placed between the bottom
% of the typeblock\index{typeblock} and the footer\index{footer}.
% Despite appearing to be lengths, if you really need to change the values
% use \cmd{\renewcommand}, not \cmd{\setlength}.
매크로 \cmd{\footruleheight}은 바닥글\tidx{footer,바닥글} 위의 기본 선의
높이이다 (기본으로 0).
\cmd{\footruleskip}은 바닥 선이 조판 영역\tidx{typeblock,조판 영역}의 하단과
바닥글\tidx{footer,바닥글} 사이에 놓일 것을 보장하는 충분한 길이이다.
길이로 보이기는 하지만, 만약 이 값을 바꾸고 싶다면 \cmd{\setlength}이 아닌
\cmd{\renewcommand}를 사용하라.

\begin{syntax}
\cmd{\makeheadposition}\marg{style}\\
    \marg{eheadpos}\marg{oheadpos}\marg{efootpos}\marg{ofootpos} \\
\end{syntax}
\glossary(makeheadposition)%
  {\cs{makeheadposition}\marg{style}\marg{eheadpos}\marg{oheadpos}\marg{efootpos}\marg{ofootpos}}%
  {Specifies the horizontal positioning of the even and odd headers and
   footers respectively for the \meta{style} pagestyle.}
% The \cmd{\makeheadposition} macro specifies the horizontal positioning
% of the even and odd headers\index{header} and footers\index{footer},
% respectively, for the \meta{style} pagestyle.
% Each of the \meta{...pos} arguments may be \texttt{flushleft}, \texttt{center},
% or \texttt{flushright}, with the obvious meanings. An empty, or unrecognised,
% argument is equivalent to \texttt{center}. This macro is really only of use
% if the header/footer\index{header}\index{footer} width is not the
% same as the \lnc{\textwidth}.
\cmd{makeheadposition} 매크로는 짝수와 홀수 머릿글\tidx{header,머릿글}과
바닥글\tidx{footer,바닥글}의 가로 위치를 \meta{style} 페이지 양식에 맞게
지정한다.
\meta{...pos} 인자 각각은 그 뜻이 분명한 \texttt{flushleft}, \texttt{center},
혹은 \texttt{flushright}이 될 수 있다.
비어있거나 알 수 없는 값은 \texttt{center}과 동일하다.
이 매크로는 머릿글/바닥글\tidx{header,머릿글}\tidx{footer,바닥글}의 너비가
\lnc{textwidth}와 같지 않을 때에만 사용된다.

\begin{syntax}
\cmd{\makepsmarks}\marg{style}\marg{code} \\
\end{syntax}
\glossary(makepsmark)
  {\cs{makepsmarks}\marg{style}\marg{code}}%
  {Hook into the \meta{style} pagestyle, usually used for the \meta{code}
   setting any marks.}
% The last thing that the \cmd{\pagestyle}\marg{style} does is call the
% \meta{code} argument of the \cmd{\makepsmarks} macro for \meta{style}.
% This is normally used for specifying non-default code
% (i.e., code not specifiable via any of the previous macros) for the
% particular pagestyle. The code normally defines the marks, if any,
% that will be used in
% the headers\index{header} and footers\index{footer}.
\cmd{\pagestyle}\marg{style}이 하는 마지막 일은 \meta{style}에 대한
\cmd{\makepsmarks} 매크로의 \meta{code} 인자를 부르는 것이다.
이는 특정 페이지 양식에 대한 비표준
코드(이전의 매크로들로는 지정할 수 없는 코드)를 지정할 때 보통 사용된다.
이 코드는 보통 머릿글\tidx{header,머릿글}과 바닥글\tidx{footer,바닥글}에서
사용될 표지를 정의한다.

\LMnote{2010/06/25}{Added a mentioning of \cs{makeheadfootstrut}}
\begin{syntax}
  \cmd{\makeheadfootstrut}\marg{style}\marg{head strut}\marg{foot strut}
\end{syntax}
% The headers and footers are each made up of three separate
% entities. At the front and end of these a special \meta{style} related
% strut is inserted. By default \cmd{\makepagestyle} will initialize
% them to \cmd{\strut} (except the \pstyle{empty} style where the struts
% are empty). One can use the macro above to change these struts to
% something different.
머릿글과 바닥글은 세 개의 다른 것들로 구성되어 있다.
처음과 끝에는 \meta{style}과 관련된 특별한 strut가 삽입되어 있다.
기본적으로 (strut가 비어 있는 \pstyle{empty} 양식을 제외하고)
\cmd{\makepagestyle}은 이들을 \cmd{\strut}에 초기화할 것이다.
이 strut들을 다른 것으로 바꿀 때는 위의 매크로를 사용할 수 있다.



% \subsection{Example pagestyles}
\subsection{예시 페이지 양식}

%     Perhaps when preparing drafts you want to note on each page
% that it is a draft\index{draft document} document. Assuming that
% you are using the
% \pstyle{headings} page style and that the default \pstyle{plain}
% page style is used on chapter openings, then you could define
% the following in the preamble (\piif{ifdraftdoc} is provided by
% the class and is set \ptrue\ when the \Lopt{draft} option is used).
여러분이 초고를 준비할 때 각 페이지에 이것이
초고\tidx{draft document,초고 문서} 문서라는 주석을 남기고 싶을 수도 있다.
여러분이 \pstyle{headings} 페이지 양식과 장 시작에 기본 \pstyle{plain} 페이지
양식을 사용하고 있다고 가정한다면, 다음을 preamble에 정의할 수
있다(\piif{ifdraftdoc}는 클래스에 의해 제공되고, \Lopt{draft} 옵션이 사용된다면
\ptrue로 설정된다).
\label{ex:draft.pagestyle}
\begin{lcode}
\ifdraftdoc
  \makeevenfoot{plain}{}{\thepage}{\textit{Draft: \today}}
  \makeoddfoot{plain}{\textit{Draft: \today}}{\thepage}{}
  \makeevenfoot{headings}{}{}{\textit{Draft: \today}}
  \makeoddfoot{headings}{\textit{Draft: \today}}{}{}
\fi
\end{lcode}
% Now when the \Lopt{draft} option is used the word `Draft:' and the current
% date will be typeset in italics at the bottom of each page by the spine
% margin. If any \pstyle{empty} pages should be marked as well, specify
% similar footers for that style as well.
이제 \Lopt{draft} 옵션이 쓰이면 단어 `Draft:'와 함께 현재 날짜가 이탤릭체로 매
페이지 하단의 책 등 여백 쪽에 식자될 것이다.
만약 \pstyle{empty} 페이지도 표시되어야 한다면, 해당 양식에도 비슷한 바닥글을
지정하라.

%     Here is part of the standard definition of the \pstyle{headings}
% pagestyle for the \Lclass{book} class which uses many internal \ltx\ commands;
% but note that \Mname\ does not use this.
여기에 여러 \ltx\ 내부 명령을 사용하는 \Lclass{book} 클래스 \pstyle{headings}
페이지 양식의 표준 정의의 일부가 나와 있다.
그러나 \Mname은 이를 사용하지 않는다는 것에 유의하라.
\begin{lcode}
\def\ps@headings{%
  \let\@oddfoot\@empty\let\@evenfoot\@empty
  \def\@evenhead{\thepage\hfil\slshape\leftmark}%
  \def\@oddhead{{\slshape\rightmark}\hfil\thepage}%
  \def\chaptermark##1{%
    \markboth{\MakeUppercase{%
      \ifnum\c@secnumdepth > \m@ne
        \if@mainmatter
          \@chapapp\ \thechapter. \ %
        \fi
      \fi
      ##1}}{}}%
  \def\sectionmark##1{%
    \markright{\MakeUppercase{%
      \ifnum\c@secnumdepth > \z@
        \thesection. \ %
      \fi
      ##1}}}}
\end{lcode}
% You don't need to understand this but in outline the first three lines specify
% the contents of the footers and headers, and the remainder of the code sets
% the marks that will be used in the headers. The \cmd{\leftmark} is specified to be
% the word `chapter',
% followed by the number if it is in the \cmd{\mainmatter} and the \texttt{secnumdepth}
% is such that chapters are numbered, followed by the chapter's title; all this
% is made to be in upper case (via the \cmd{\MakeUppercase} macro). Similarly
% the other mark, \cmd{\rightmark}, is the section number, if there is one, and
% the section's title, again all in upper case.
이를 이해할 필요는 없지만, 개략적으로 첫 세 줄은 바닥글과 머릿글의 내용을
지정하고, 나머지 코드는 머릿글에 사용될 표지를 지정한다.
\cmd{\leftmark}는 `chapter'라는 단어 뒤에, \cmd{\mainmatter}에 있으며
\texttt{secnumdepth}가 해당 장에 번호가 붙도록 설정되어 있다면 번호가 붙고,
뒤에 장의 제목이 붙도록 지정된다.
이 모두는 (\cmd{\MakeUppercase} 매크로에 의해) 대문자가 된다.
비슷하게 다른 표지인 \cmd{\rightmark}도 있다면 절 번호와 절의 제목이 모두
대문자로 된다.

    % A transliteration of this code into \Mname's original coding style is:
이 코드를 \Mname의 코딩 양식으로 의역한다면 다음과 같다.
\begin{lcode}
\makepagestyle{headings}
\makeevenhead{headings}{\thepage}{}{\slshape\leftmark}
\makeoddhead{headings}{\slshape\rightmark}{}{\thepage}
\makepsmarks{headings}{%
  \def\chaptermark##1{%
    \markboth{\MakeUppercase{%
      \ifnum\c@secnumdepth > \m@ne
        \if@mainmatter
          \@chapapp\ \thechapter. \ %
        \fi
      \fi
      ##1}}{}}%
  \def\sectionmark##1{%
    \markright{\MakeUppercase{%
      \ifnum\c@secnumdepth > \z@
        \thesection. \ %
      \fi
      ##1}}}
  \def\tocmark{\markboth{\MakeUppercase{\contentsname}}{}}
  \def\lofmark{\markboth{\MakeUppercase{\listfigurename}}{}}
  \def\lotmark{\markboth{\MakeUppercase{\listtablename}}{}}
  \def\bibmark{\markboth{\MakeUppercase{\bibname}}{}}
  \def\indexmark{\markboth{\MakeUppercase{\indexname}}{}}
  \def\glossarymark{\markboth{\MakeUppercase{\glossaryname}}{}}}
\end{lcode}
% As you can see, defining the marks for a pagestyle is not necessarily the
% simplest thing in the world. However, courtesy of Lars\index{Madsen, Lars} Madsen,
% help is at hand.
여러분이 볼 수 있듯, 페이지 양식의 표지를 정의하는 것이 그렇게 간단하지만은
않은 일이다.
그러나 Lars\index{Madsen, Lars} Madsen의 도움으로 일이 간단해졌다.

\begin{syntax}
\cmd{\createplainmark}\marg{type}\marg{marks}\marg{text} \\
\cmd{\memUChead}\marg{text} \\
\cmd{\uppercaseheads} \cmd{\nouppercaseheads} \\
\cmd{\createmark}\marg{sec}\marg{marks}\marg{show}\marg{prefix}\marg{postfix} \\
\end{syntax}
\glossary(createplainmark)%
  {\cs{createplainmark}\marg{type}\marg{marks}\marg{text}}%
  {Defines the \cs{typemark} macro using \meta{text} as the mark, where
  \meta{marks} is \texttt{left}, \texttt{both} or \texttt{right}.}
\glossary(createmark)%
  {\cs{createmark}\marg{sec}\marg{marks}\marg{show}\marg{prefix}\marg{postfix}}%
  {Defines the \cs{secmark} macro where \meta{show} (\texttt{shownumber} 
   or \texttt{nonumber}) controls whether the division number will be
   displayed within \cs{mainmatter}, \meta{marks} is \texttt{left}, 
   \texttt{both} or \texttt{right}, and \meta{prefix} and \meta{postfix}
   are affixed before and after the \meta{sec} (division) number.}
\glossary(memUChead)%
  {\cs{memUChead}\marg{text}}%
  {May uppercase \meta{text}, depending on \cs{uppercaseheads} and
  \cs{nouppercaseheads}.}
\glossary(uppercaseheads)%
  {\cs{uppercaseheads}}%
  {Defines \cs{memUChead} as equivalent to \cs{MakeUppercase}.}
\glossary(nouppercaseheads)%
  {\cs{nouppercaseheads}}%
  {Defines \cs{memUChead} as \cs{relax} (i.e., do nothing).}


% The macro \cmd{\createplainmark} defines the \verb?\<type>mark?, where
% \meta{type} is an unnumbered division-like head, such as \texttt{toc},
% \texttt{lof}, \texttt{index}, using \meta{text} as the mark value, and
% \meta{marks} is \texttt{left}, \texttt{both} or \texttt{right}. For example:
매크로 \cmd{\createplainmark}는 \verb|\<type>mark|를 정의하는데, \meta{type}은
번호 붙지 않은 \texttt{toc}, \texttt{lof}, \texttt{index}와 같은 영역의
머릿글로 \meta{text}를 표지 값으로 사용하고, \meta{marks}는 \texttt{left},
\texttt{both}, 혹은 \texttt{right}이다.
예를 들어
\begin{lcode}
\createplainmark{toc}{left}{\contentsname}
\createplainmark{lot}{right}{\listtablename}
\createplainmark{bib}{both}{\bibname}
\end{lcode}
% is equivalent to
은 다음과 같다.
\begin{lcode}
\def\tocmark{\markboth{\memUChead{\contentsname}}{}}
\def\lotmark{\markright{\memUChead{\listtablename}}}
\def\lofmark{\markboth{\memUChead{\bibname}}{\memUChead{\bibname}}}
\end{lcode}

%     Following the declaration \cmd{\uppercaseheads} the \cmd{\memUChead}
% command is equivalent to \cmd{\MakeUppercase} but after the
% \cmd{\nouppercaseheads} it is equivalent to \cmd{\relax} (which does nothing).
% The \cmd{\createplainmark} macro wraps \cmd{\memUChead} around the \meta{text}
% argument within the generated \cs{mark(both/right)} macro. By using the
% \cs{(no)uppercaseheads} declarations you can control the uppercasing, or
% otherwise, of the mark texts. The default is \cmd{\uppercaseheads}.
\cmd{\uppercaseheads}의 정의에 뒤따르는 \cmd{\memUChead} 명령은
\cmd{\MakeUppercase}와 동일하지만 \cmd{\nouppercaseheads}에 뒤따를 때는
(아무것도 하지 않는) \cmd{\relax}와 동일하다.
\cmd{\createplainmark} 매크로는 \cmd{\memUChead}를 생성된 \cs{mark(both/right)}
매크로의 \meta{text} 인자 양 옆에 감싼다.
\cs{(no)uppercaseheads} 선언을 사용해 여러분은 대문자나 표지 문구를 조정할 수
있다.
기본은 \cmd{\uppercaseheads}이다.

\LMnote{2010/02/08}{added the following paragraph}
% Note that if you want to use a predefined page style, but would like
% to not use automatic uppercasing, then issue \cs{nouppercaseheads} and
% reload the page style, for example with the default page style in \theclass\
만약 여러분이 사전 정의된 페이지 양식을 쓰고 싶은데 자동 대문자를 사용하고 싶지
않다면, \cs{nouppercaseheads}를 쓴 후 페이지 양식을 다시 불러야 한다.
예를 들어, \theclass의 기본 페이지 양식을 쓴다면 다음과 같이 하라.
\begin{lcode}
  \nouppercaseheads
  \pagestyle{headings}
\end{lcode}


%     The macro \cmd{\createmark}\marg{sec}\marg{marks}\marg{show}\marg{prefix}\marg{postfix}
% defines the \verb?\<sec>mark? macro where \meta{sec} is a sectional division
% such as \texttt{part}, \texttt{chapter}, \texttt{section}, etc.,
% and \meta{show} (\texttt{shownumber}
% or \texttt{nonumber}) controls whether the division number will be
% displayed within \cs{mainmatter}. The \meta{marks} argument is \texttt{left},
% \texttt{both} or \texttt{right}, and \meta{prefix} and \meta{postfix}
% are affixed before and after the division number. For example:
매크로
\cmd{\createmark}\marg{sec}\marg{marks}\marg{show}\marg{prefix}\marg{postfix}는
\meta{sec}이 \texttt{part}, \texttt{chapter}, \texttt{section}등과 같은 절
구획에 해당하고, \meta{show}(\texttt{shownumber} 혹은 \texttt{nonumber})가
\cs{mainmatter}에 구획 번호가 표시될지 결정할 때, \verb|\<sec>mark|를 정의한다.
\meta{marks} 인자는 \texttt{left}, \texttt{both} 혹은 \texttt{right}이고,
\meta{prefix}와 \meta{postfix}는 구획 번호 앞과 뒤에 첨부된다.
예를 들어
\begin{lcode}
\createmark{section}{left}{nonumber}{}{}
\createmark{section}{both}{nonumber}{}{}
\createmark{section}{right}{nonumber}{}{}
\end{lcode}
% is equivalent to, respectively
는 각각 다음과 같다.
\begin{lcode}
\def\sectionmark#1{\markboth{#1}{}}
\def\sectionmark#1{\markboth{#1}{#1}}
\def\sectionmark#1{\markight{#1}}
\end{lcode}

% The difference between \cmd{\createmark} and \cmd{\createplainmark} is
% that the former create a macro that takes an argument, whereas
% \cmd{\createplainmark} does not.
\cmd{\createmark}와 \cmd{\createplainmark}의 차이는, 전자는 인자를 취하는
매크로를 만들고 \cmd{\createplainmark}는 그렇지 않다는 것이다.


%     Using these macros \Mname's current definition of
% \verb?\makepsmarks{headings}? is much simpler (it also leads to a
% slightly different result as the \texttt{toc} etc., marks set both
% the \cmd{\leftmark} and \cmd{\rightmark} instead of just the
% \cmd{\leftmark}):
이 명령들을 사용해서 \Mname의 \verb|\makepsmarks{headings}|의 현재 정의는 훨씬
간결하다 (이는 또한 \texttt{toc} 등이 \cmd{\leftmark}만이 아니라
\cmd{\leftmark}와 \cmd{\rightmark} 둘 다 표시하기 때문에 약간 다른 결과를
만든다).
\begin{lcode}
\makepsmarks{headings}{%
  \createmark{chapter}{left}{shownumber}{\@chapapp\ }{. \ }
  \createmark{section}{right}{shownumber}{}{. \ }
  \createplainmark{toc}{both}{\contentsname}
  \createplainmark{lof}{both}{\listfigurename}
  \createplainmark{lot}{both}{\listtablename}
  \createplainmark{bib}{both}{\bibname}
  \createplainmark{index}{both}{\indexname}
  \createplainmark{glossary}{both}{\glossaryname}}
\end{lcode}


\LMnote{2010/02/08}{fixed typo}
% When \Mname{} runs the marks part of page style, it does not zero out
% old marks, i.e.\ if an old \cmd{\sectionmark} exist, it still exist
% even if we do not change it.  This is both a good and a bad thing. To help
% users redefine these marks to doing nothing we provide
\Mname이 페이지 양식의 표지 부분을 행할 때, 이는 오래된 표지를 없애지 않는다.
즉, 만약 예전 \cmd{\sectionmark}가 존재한다면 우리가 바꾸지 않더라도 이는
여전히 존재한다.
이는 좋을 수도, 나쁠 수도 있는 일이다.
사용자가 이 표지들이 아무것도 하지 않게 재정의할 수 있도록 우리는 다음을
제공한다.
\begin{syntax}
\cmd{\clearplainmark}\marg{type}\\
\cmd{\clearmark}\marg{type}\\  
\end{syntax}
% The used types are the same as for \cmd{\createplainmark} and \cmd{\createmark}.
사용되는 인자 종류는 \cmd{\createplainmark} 및 \cmd{\createmark}와 같다.



\PWnote{2009/07/30}{Added sections on Document title and Part title in headers}
% \subsubsection{Header with the document title}
\subsubsection{문서 제목이 있는 머릿글}

%     As mentioned before, some publishers like the title of the book
% to be in the header. A simple header is probably all that is needed
% as it is unlikely to be a technical publication. Here is a
% use for \pstyle{myheadings}.
앞서 언급하였듯, 일부 출판사는 책의 제목이 머릿글에 제목이 들어가기를 선호한다.
아마도 이는 기술적인 출판물이 아닐 것이기에 간단한 머릿글이면 충분할 것이다.
여기에 \pstyle{myheading}의 사용례가 있다.
\begin{lcode}
\makevenhead{myheadings}{\thepage}{}{DOCUMENT TITLE}
\makeoddhead{myheadings}{Chapter~\thechapter}{}{\thepage}
\end{lcode}

% \subsubsection{Part and chapter in the header}
\subsubsection{머릿글의 부(部)와 장(章)}

%     Some documents have both part and chapter divisions and in such
% cases it may be useful for the reader to have the current part and chapter
% titles in the header. The \pstyle{headings} pagestyle can be easily modified
% to accomplish this by simply resetting the marks for part and chapter:
일부 문서는 부와 장 구획을 둘 다 가지고 있고, 이런 경우에는 머릿글에 현재 부와
장 제목이 있으면 독자들에게 유용할 수 있다.
\pstyle{headings} 페이지 양식은 부와 장 표지를 재설정함으로써 이를 쉽게 구현할
수 있다.
\begin{lcode}
\makepsmarks{headings}{%
  \createmark{part}{left}{shownumber}{\partname\ }{. \ }
  \createmark{chapter}{right}{shownumber}{\@chapapp\ }{. \ }
  \createplainmark{toc}{both}{\contentsname}
  \createplainmark{lof}{both}{\listfigurename}
  \createplainmark{lot}{both}{\listtablename}
  \createplainmark{bib}{both}{\bibname}
  \createplainmark{index}{both}{\indexname}
  \createplainmark{glossary}{both}{\glossaryname}}
\end{lcode}
  

% \subsubsection{The Companion pagestyle}
\subsubsection{Companion 페이지 양식}

%     This example demonstrates most of the page styling commands.
% In the \textit{\ltx\ Companion} series of
% books~\cite{COMPANION,GCOMPANION,WCOMPANION} the header\index{header} is wider
% than the typeblock\index{typeblock}, sticking out into the outer
% margin\index{margin!outer}, and has a rule underneath it.
% The page number is in
% bold and at the outer end of the header\index{header}.
% Chapter titles are in verso headers\index{header} and section titles
% in recto headers\index{header}, both in bold font and at the inner
% margin\index{margin!inner}. The footers\index{footer} are empty.
이 예시는 대부분의 페이지 양식 명령을 보여준다.
\textit{\ltx\ Companion} 시리즈~\cite{COMPANION,GCOMPANION,WCOMPANION}에는
머릿글\tidx{header,머릿글}이 조판 영역\tidx{typeblock,조판 영역}보다 넓어 바깥
여백\tidx{margin!outer,여백!바깥}으로 삐져 나와 있고, 아래에 괘선이 있다.
페이지 번호는 볼드체로 머릿글 바깥쪽에 있다.
장 제목은 왼쪽 머릿글\tidx{header,머릿글}에 있고 절 제목은 오른쪽
머릿글\tidx{header,머릿글}에 둘 다 볼드체로 안쪽
여백\tidx{margin!inner,여백!안쪽}에 있다.
바닥글\tidx{footer,바닥글}은 비어 있다.

%     The first thing to do in implementing this style is to calculate
% the width of the headers\index{header}, which extend to cover any
% marginal\index{marginalia} notes.
이 양식을 구현하기 위해서 해야할 첫 번째 일은 여백 주석\tidx{marginalia,방주}을
덮는 머릿글의 너비를 계산하는 것이다.
\begin{lcode}
\setlength{\headwidth}{\textwidth}
  \addtolength{\headwidth}{\marginparsep}
  \addtolength{\headwidth}{\marginparwidth}
\end{lcode}
% Now we can set up an empty \pstyle{companion} pagestyle and start to change
% it by specifying the new header\index{header} and footer\index{footer} width:
이제 우리는 빈 \pstyle{companion} 페이지 양식을 만들고 새로운
머릿글\tidx{header,머릿글}과 바닥글\tidx{footer,바닥글} 너비를 지정하는 것으로
시작하면 된다.
\begin{lcode}
\makepagestyle{companion}
\makerunningwidth{companion}{\headwidth}
\end{lcode}
% and specify the width and thickness for the header\index{header} rule,
% otherwise it will be invisible.
그리고 머릿글\tidx{header,머릿글} 괘선의 너비와 두께를 설정해야 보일 것이다.
\begin{lcode}
\makeheadrule{companion}{\headwidth}{\normalrulethickness}
\end{lcode}

%     In order to get the header\index{header} to stick out into the \foredge\
% margin\index{margin!foredge?\foredge}, verso headers\index{header}
% have to be flushright
% (raggedleft) and recto headers\index{header} to be flushleft (raggedright).
% As the footers\index{footer} are empty, their position is immaterial.
머릿글이 재단 여백\tidx{margin!foredge,여백!재단}으로 삐져 나오려면 왼쪽
머릿글\tidx{header,머릿글}은 우측 정렬되어야 하고, 오른쪽
머릿글\tidx{header,머릿글}은 좌측 정렬되어야 한다.
바닥글\tidx{footer,바닥글}은 비어 있으므로, 이 영역은 중요하지 않다.
\begin{lcode}
\makeheadposition{companion}{flushright}{flushleft}{}{}
\end{lcode}

%     The current chapter and section titles are obtained from the
% \cmd{\leftmark} and \cmd{\rightmark} macros which are defined via the
% \cmd{\chaptermark} and \cmd{\sectionmark} macros. Remember that
% \cmd{\leftmark} is the last \meta{left} marker and \cmd{\rightmark}
% is the first \meta{right} marker\index{markers} on the page.
현재 장과 절 제목은 \cmd{\leftmark}와 \cmd{\rightmark} 매크로에서부터 얻는데,
이들은 \cmd{\chaptermark}와 \cmd{\sectionmark} 매크로로 정의된다.
\cmd{\leftmark}는 페이지의 마지막 \meta{left} 표지이고 \cmd{\rightmark}는 첫
\meta{right} 표지\tidx{markers,표지}임을 기억하자.

% Chapter numbers are not
% put into the header\index{header} but the section number,
% if there is one, is put into
% the header\index{header}. We have to make sure that
% the correct definitions are used for these as well as for the
% \toc\footnote{The \toc\ and friends are described in detail
% in \protect\Cref{chap:toc}.}
% and other similar elements, and this is where the
% \cmd{\makepsmarks} macro comes into play.
장 번호는 머릿글\tidx{header,머릿글}에 넣지 않지만 절 번호는 있다면
머릿글\tidx{header,머릿글}에 들어간다.
우리는 이들과 다른 비슷한 요소\toc\footnote{\toc와 관련 내용은
\protect\Cref{chap:toc}에 자세히 설명되어 있다.}에 올바른 정의가 사용되었는지
주의를 기울여야 하고, 이때 \cmd{\makepsmarks} 매크로를 사용하게 된다.
\begin{lcode}
\makepsmarks{companion}{%
  \nouppercaseheads
  \createmark{chapter}{both}{nonumber}{}{}
  \createmark{section}{right}{shownumber}{}{. \space}
  \createplainmark{toc}{both}{\contentsname}
  \createplainmark{lof}{both}{\listfigurename}
  \createplainmark{lot}{both}{\listtablename}
  \createplainmark{bib}{both}{\bibname}
  \createplainmark{index}{both}{\indexname}
  \createplainmark{glossary}{both}{\glossaryname}
\end{lcode}

%     The preliminaries have all been completed, and it just remains to specify
% what goes into each header\index{header} and footer\index{footer} slot
% (but the footers\index{footer} are empty).
준비 작업은 모두 완료되었고, 이제 각 머릿글\tidx{header,머릿글}과
바닥글\tidx{footer,바닥글} 영역에 어떤 내용이 들어갈지만 지정하면 된다 (그러나
바닥글\tidx{footer,바닥글}은 비어 있다).
\begin{lcode}
\makeevenhead{companion}%
  {\normalfont\bfseries\thepage}{}{%
   \normalfont\bfseries\leftmark}
\makeoddhead{companion}%
  {\normalfont\bfseries\rightmark}{}{%
   \normalfont\bfseries\thepage}
\end{lcode}

%     Now issuing the command \verb?\pagestyle{companion}? will produce pages
% typeset with \pstyle{companion} pagestyle headers\index{header}. This pagestyle
% is part of the class.
이제 \verb|\pagestyle{companion}| 명령을 주면 \pstyle{companion} 페이지 양식
머릿글\tidx{header,머릿글}을 가진 페이지가 조판될 것이다.
이 페이지 양식은 본 클래스에 포함되어 있다.

\begin{syntax}
\cmd{\addtopsmarks}\marg{pagestyle}\marg{prepend}\marg{append} \\
\end{syntax}
\glossary(addtopsmarks)%
  {\cs{addtopsmarks}\marg{pagestyle}\marg{prepend}\marg{append}}%
  {Inserts \meta{prepend} and \meta{append} before and after the current
   definition of \cs{makepsmarks} for \meta{pagestyle}.}
% \cmd{\addtopsmarks}\marg{pagestyle}\marg{prepend}\marg{append} is the last
% of this group of helper macros. It inserts \meta{prepend} and \meta{append}
% before and after the current definition of \cs{makepsmarks}
% for \meta{pagestyle}. For instance, if you wanted \cs{subsection} titles to appear
% in the page headers of the \pstyle{companion} pagestyle then this would be a way
% of doing it:
\cmd{\addtopsmarks}\marg{pagestyle}\marg{prepend}\marg{append}는 이 보조 매크로
모음의 마지막 매크로이다.
이는 \meta{prepend}와 \meta{append}를 \meta{pagestyle}에 대한
\cs{makepsmarks}의 현 정의 전과 후에 삽입한다.
예를 들어, 만약 여러분이 \pstyle{companion} 페이지 양식의 페이지 머릿글에
\cs{subsection} 제목이 나타나기를 원한다면 다음과 같이 할 수 있다.
\begin{lcode}
\addtopsmarks{companion}{}{%
  \createmark{subsection}{right}{shownumber}{}{. \space}}
\end{lcode}


% \subsubsection{The ruled pagestyle}
\subsubsection{ruled 페이지 양식}

%     For practical reasons I prefer a page style with headings
% where the chapter title is at least in the center
% of the page, and for technical works is at the \foredge. I also prefer the
% page number to be near the outside edge. When picking up a book and skimming
% through it, either to get an idea of what is in it or to find something more
% specific, I hold it in one hand at the spine and use the other for flicking
% the pages. The book is half closed while doing this and it's much easier
% to spot things at the \foredge\ than those nearer the spine.
% The \pstyle{ruled} page style is like this. The general plan is defined as:
필자는 실용적인 이유로 장 제목이 머릿글에 적어도 페이지 중앙에, 기술적인 저술에
대해서는 재단 여백 쪽에 있는 페이지 양식을 선호한다.
필자는 또한 페이지 번호가 바깥쪽 모서리에 위치하는 것을 선호한다.
책을 집어 들어 훑어볼 때, 안에 어떤 내용이 있는지 알아보거나 좀 더 구체적인
내용을 찾을 때, 필자는 한 손으로 책 등을 잡고 다른 손으로 페이지를 넘긴다.
이때 책이 반쯤 접혀 있기 때문에 책등 가까이 있는 것보다는 재단 여백 쪽에 위치한
것들이 더 눈에 잘 띈다.
ruled 페이지 양식은 이와 같다.
일반적인 내용은 다음과 같다.
\begin{lcode}
\makepagestyle{ruled}
\makeevenfoot {ruled}{\thepage}{}{} % page numbers at the outside
\makeoddfoot  {ruled}{}{}{\thepage}
\makeheadrule {ruled}{\textwidth}{\normalrulethickness}
\makeevenhead {ruled}{\scshape\leftmark}{}{} % small caps
\makeoddhead  {ruled}{}{}{\rightmark}
\end{lcode}
% The other part of the specification has to ensure that the \cmd{\chapter}
% and \cmd{\section} commands make the appropriate marks for the headers.
% I wanted the numbers to appear in the headers, but not those for sections. The following
% code sets these up, as well as the marks for the other document elements.
설정의 나머지 부분은 \cmd{\chapter}와 \cmd{\section} 명령어가 머릿글에 대해서
적절한 표지를 남기도록 한다.
필자는 머릿글에 장 번호는 나오지만 절 번호는 그렇지 않도록 하고 싶었다.
다음 코드는 이와 더불어 다른 문서 요소에 대한 표지를 설정한다.
\begin{lcode}
\makepsmarks{ruled}{%
  \nouppercaseheads
  \createmark{chapter}{left}{shownumber}{}{. \space}
  \createmark{section}{right}{nonumber}{}{}
  \createplainmark{toc}{both}{\contentsname}
  \createplainmark{lof}{both}{\listfigurename}
  \createplainmark{lot}{both}{\listtablename}
  \createplainmark{bib}{both}{\bibname}
  \createplainmark{index}{both}{\indexname}
  \createplainmark{glossary}{both}{\glossaryname}
}
\end{lcode}

% \index{pagestyle!specifying|)}
\tidx{pagestyle!specifying|),페이지 양식!지정|)}



% \subsection{Index headers}
\subsection{색인 머릿글}

% \index{pagestyle!index pages|(}
\tidx{pagestyle!index pages|(,페이지 양식!색인 페이지|(}

%     If you look at the Index\index{index} you will see that the header\index{header}
% shows the first and last entries on the page.
% A main entry in the index\index{index} looks like:
여러분이 색인\tidx{index,인덱스}를 보면 머릿글\tidx{header,머릿글}이 해당
페이지의 시작과 마지막 표제어를 보여주는 것을 확인할 수 있다.
색인\tidx{index,색인}의 중심 표제어는 다음과 같다.
\begin{lcode}
\item \idxmark{entry}, page number(s)
\end{lcode}
% and in the preamble\index{preamble} to this book \cmd{\idxmark} is defined as
그리고 이 책의 프리앰블\tidx{preamble,프리앰블}에서 \cmd{\idxmark}는 다음과
같이 정의되어 있다.
\begin{lcode}
\newcommand{\idxmark}[1]{#1\markboth{#1}{#1}}
\end{lcode}
% This typesets the entry and also uses the entry as markers so that
% the first entry on a page is held in \cmd{\rightmark} and the last
% is in \cmd{\leftmark}.
이는 표제어를 식자할 뿐만이 아니라, 표제어를 표지로 사용해 처음 표제어는
\cmd{\rightmark}에, 마지막 표제어는 \cmd{\leftmark}에 넣도록 한다.

%     As index\index{index} entries are usually very short, the
% Index\index{index} is set in two columns\index{column!double}.
% Unfortunately \ltx's marking mechanism can be very
% fragile on twocolumn\index{column!double} pages.\footnote{This was
%   fixed in the \LaTeX{} kernel, but including the functionality from
%   the \Lpack{fixltx2e} package.}
색인\tidx{index,색인} 표제어는 보통 매우 짧아서, 색인\tidx{index,색인}은 두
단\tidx{column!double,단!두}으로 되어 있다.
불행히도 \ltx의 표지 방식이 두 단\tidx{colummn!double} 페이지에서는 매우 깨지기
쉽다.\footnote{이는 \LaTeX{} 커널에서 고쳐졌지만, \Lpack{fixltx2e} 패키지의
기능을 포함한다.}

    % The index\index{index} itself is called by\index{indexing}
색인\tidx{index,색인}은 다음에 의해 불려진다.\tidx{indexing,색인화}
\begin{lcode}
\clearpage
\pagestyle{index}
\renewcommand{\preindexhook}{%
The first page number is usually, but not always, 
the primary reference to
the indexed topic.\vskip\onelineskip}
\printindex
\end{lcode}

\makepagestyle{index}
  \makeheadrule{index}{\textwidth}{\normalrulethickness}
  \makeevenhead{index}{\rightmark}{}{\leftmark}
  \makeoddhead{index}{\rightmark}{}{\leftmark}
  \makeevenfoot{index}{\thepage}{}{}
  \makeoddfoot{index}{}{}{\thepage}

%     The \pstyle{index} pagestyle, which is the crux of
% this example, is defined here as:
본 예시의 핵심인 \pstyle{index} 페이지 양식은 다음과 같이 정의된다.
\begin{lcode}
\makepagestyle{index}
  \makeheadrule{index}{\textwidth}{\normalrulethickness}
  \makeevenhead{index}{\rightmark}{}{\leftmark}
  \makeoddhead{index}{\rightmark}{}{\leftmark}
  \makeevenfoot{index}{\thepage}{}{}
  \makeoddfoot{index}{}{}{\thepage}
\end{lcode}
% This, as you can hopefully see, puts the first and last index\index{index}
% entries on the page into the header\index{header} at the left and right,
% with the folios\index{folio} in the footers\index{footer} at the
% outer margin\index{margin!outer}.
여러분이 아마 볼 수 있듯 이는 페이지의 처음과 마지막
색인\tidx{index,표제어} 표제어를 머릿글\tidx{header,머릿글}의 왼쪽과 오른쪽에
넣고, 폴리오\tidx{folio,폴리오}를 바깥 여백\tidx{margin!outer,여백!바깥쪽}의
바닥글\tidx{footer,바닥글}에 넣는다.

% \index{pagestyle!index pages|)}
\tidx{pagestyle!index pages|),페이지 양식!색인 페이지|)}

% \subsection{Float pages}
\subsection{떠다니는 페이지}

% \index{pagestyle!float pages|(}
% \index{float!page|(}
\tidx{pagestyle!float pages|(,페이지 양식!떠다니는 페이지|(}
\tidx{float!page|(,떠다니는!페이지|(}

\begin{syntax}
\piif{ifonlyfloats}\marg{yes}\marg{no} \\
\end{syntax}
\glossary(ifonlyfloats)%
  {\cs{ifonlyfloats}\marg{yes}\marg{no}}%
  {Processes \meta{yes} on a page containing only floats, otherwise process
  \meta{no}.}
%     There are occasions when it is desirable to have different
% headers\index{header} on pages that only contain figures\index{figure}
% or tables\index{table}. If the command \piif{ifonlyfloats}
% is issued on a page that contains no text and only floats then the \meta{yes}
% argument is processed, otherwise on a normal page the \meta{no} argument
% is processed. The command is most useful when defining a pagestyle that
% should be different on a float-only page\index{page!of floats}.
페이지가 글 없이 그림\tidx{figure,그림}이나 표\tidx{table,표}만을 담고 있을 때,
다른 머릿글\tidx{header,머릿글}을 넣어야 할 때가 있다.
만약 \piif{ifonlyfloats} 명령어가 글 없이 떠다니는 개체만 있는 페이지에 사용될
경우, \meta{yes} 인자가 처리되며 그렇지 않은 일반적인 페이지의 경우 \meta{no}
인자가 처리된다.
해당 명령은 떠다니는 개체뿐인
페이지\index{page!of floats,떠다니는 개체뿐인!페이지}에만 다르게 적용될 페이지
양식을 정의할 때 유용하다.

%     For example, assume that the \pstyle{companion} pagestyle is to be
% generally used, but on float-only pages all that is required is a pagestyle
% similar to \pstyle{plain}. Borrowing some code from the \pstyle{companion}
% specification this can be accomplished like:
예컨대 \pstyle{companion} 페이지 양식을 주로 사용하지만, 떠다니는 개체뿐인
페이지에서는 \pstyle{plain} 정도의 페이지 양식만 필요하다고 하자.
\pstyle{companion}의 설정에서 일부 코드를 빌려다가 쓴다면 다음과 같이 할 수
있다.
\begin{lcode}
\makepagestyle{floatcomp}
% \headwidth has already been defined for the companion style
\makeheadrule{floatcomp}{\headwidth}%
  {\ifonlyfloats{0pt}{\normalrulethickness}}
\makeheadposition{floatcomp}{flushright}{flushleft}{}{}
\makepsmarks{floatcomp}{\companionpshook}
\makeevenhead{floatcomp}%
             {\ifonlyfloats{}{\normalfont\bfseries\thepage}}%
             {}%
             {\ifonlyfloats{}{\normalfont\bfseries\leftmark}}
\makeoddhead{floatcomp}%
             {\ifonlyfloats{}{\normalfont\bfseries\rightmark}}%
             {}%
             {\ifonlyfloats{}{\normalfont\bfseries\thepage}}
\makeevenfoot{floatcomp}{}{\ifonlyfloats{\thepage}{}}{}
\makeoddfoot{floatcomp}{}{\ifonlyfloats{\thepage}{}}{}
\end{lcode}
% The code above for the \pstyle{floatcomp} style should be compared with
% that for the earlier \pstyle{companion} style.
\pstyle{floatcomp} 양식에 대한 위 코드를 앞서 나온 \pstyle{companion} 양식의
것과 비교해보자.

%     The headrule is invisible\index{rule!thickness}\index{rule!invisible}
% on float pages by giving it zero thickness,
% otherwise it has the \cmd{\normalrulethickness}. The head position is
% identical for both pagestyles. However, the headers\index{header} are empty for
% \pstyle{floatcomp} and the footers\index{footer} have centered page numbers
% on float pages; on ordinary pages the footers\index{footer} are empty
% while the headers\index{header}
% are the same as the \pstyle{companion} headers\index{header}.
머리괘선은 떠다니는 페이지에서 두께가 영이 되어 보이지
않고\tidx{rule!thickness,괘선!두께}\tidx{rule!invisible,괘선!보이지 않는} 다른
페이지에는 \cmd{\normalrulethickness}의 두께를 가진다.
머리의 위치는 두 페이지 양식 모두 동일하다.
그러나 \pstyle{floatcomp}에서 머릿글\tidx{header,머릿글}은 비어있고,
떠다니는 페이지의 바닥글\tidx{footer,바닥글}은 가운데에 페이지 번호를 가진다.
일반적인 페이지에서 바닥글\tidx{footer,바닥글}은 비어있지만
머릿글\tidx{header,머릿글}은 \pstyle{companion}의 머릿글\tidx{header,머릿글}과
같다.

%     The code includes one `trick'. The macro \cmd{\makepsmarks}\verb?{X}{code}?
% is equivalent to
다음 코드는 `요령' 하나를 담고 있다.
매크로 \cmd{\makepsmarks}\verb|{x}{code}|는
\begin{lcode}
\newcommand{\Xpshook}{code}
\end{lcode}
와 같다.
% I have used this knowledge in the line:
필자는 이를 다음 코드에 적용하였다.
\begin{lcode}
\makepsmarks{floatcomp}{\companionpshook}
\end{lcode}
% which avoids retyping the code from
이는
\verb?\makepsmarks{companion}{...}?,
% and ensures that the code is actually the same for the two pagestyles.
을 번복하지 않으면서도 코드가 두 페이지 양식에 대해 동일하도록 보장한다.

\begin{syntax}
\cmd{\mergepagefloatstyle}\marg{style}\marg{textstyle}\marg{floatstyle} \\
\end{syntax}
%     If you have two pre-existing pagestyles, one that will be used for
% text pages and the other that can be used for float pages, then the
% \cmd{\mergepagefloatstyle} command provides a simpler means of
% combining\index{pagestyle!combining}
% them than the above example code for \pstyle{floatcomp}. The argument
% \meta{style} is the name of the pagestyle being defined. The
% argument \meta{textstyle}
% is the name of the pagestyle for text pages and \meta{floatstyle} is the
% name of the pagestyle for float-only pages. Both of these must have been
% defined before calling \cmd{\mergepagefloatstyle}. So, instead of the long
% winded, and possibly tricky, code I could have simply said:
여러분이 하나는 본문 페이지에, 다른 하나는 떠다니는 페이지에 적용할 두 개의
페이지 양식을 이미 가지고 있다면, \cmd{\mergepagefloatstyle} 명령어는 위의
\pstyle{floatcomp} 예시 코드보다 간단하게 페이지 양식을
결합할\tidx{pagestyle!combining,페이지 양식!결합} 수 있도록 제공된다.
\meta{style} 인자는 정의되고 있는 페이지 양식의 이름이다.
\meta{textstyle} 인자는 본문 페이지에 대한 페이지 양식의 이름,
\meta{floatstyle}은 떠다니는 페이지에 적용될 페이지 양식의 이름이다.
이들 둘 다 \cmd{\mergepagefloatstyle}을 부르기 전에 정의되어 있어야 한다.
따라서, 필자는 길고 복잡할 수도 있는 코드 대신에 다음의 코드를 사용할 수
있었다.
\begin{lcode}
\mergepagefloatstyle{floatcomp}{companion}{plain}
\end{lcode}


%     One author thought it would be nice to be able to have different
% page headings according
% to whether the page was a floatpage, or there was a float at the top of
% the page, or a float at the bottom of a page or there was text at the
% top and bottom.
어떤 저자는 페이지가 떠다니는 페이지인지, 떠다니는 개체가 페이지의 꼭대기에
있는지, 떠다니는 개체가 페이지의 바닥에 있는지, 혹은 본문이 꼭대기와 바닥에
있는지에 따라서 페이지 머릿글을 다르게 하면 좋을 수 있을 것 같다고 생각하였다.

%     This, I think, is not a common requirement and, further, that to provide
% this involves changing parts of the LaTeX output routine --- something only
% to be tackled by the bravest of the brave. If it were to be done then were
% best done in a package that could be easily ignored. The following is an
% outline of what might be done; I do not recommend it and if you try this
% and all your work dissappears then on your own head be it.
필자는 이것이 통상적인 요구사항이 아니라고 생각할 뿐만이 아니라, 이를 가능하게
하려면 LaTeX의 출력 과정을 손봐야 하는데, 이는 큰 용기를 필요로 하는 일이다.
만약 이를 해야 한다면 쉽게 무시할 수 있는 패키지로 만들어야 할 것이다.
다음은 이를 위해 해야하는 작업의 윤곽으로, 필자는 권장하지 않는다.
혹여나 여러분이 시도하였는데 모든 작업이 사라져버리더라도 전적으로 여러분의
책임이다.

\begin{lcode}
% notefloat.sty
\newif\iffloatattop
  \floatattopfalse
\newif\iffloatatbot
  \floatatbotfalse

\renewcommand*{\@addtotoporbot}{%
  \@getfpsbit \tw@
  \ifodd \@tempcnta
    \@flsetnum \@topnum
    \ifnum \@topnum>\z@
      \@tempswafalse
      \@flcheckspace \@toproom \@toplist
      \if@tempswa
        \@bitor\@currtype{\@midlist\@botlist}%
        \if@test
        \else
          \@flupdates \@topnum \@toproom \@toplist
          \@inserttrue
  \global\floatattoptrue
        \fi
      \fi
    \fi
  \fi
  \if@insert
  \else
    \@addtobot
  \fi}

\renewcommand*{\@addtobot}{%
  \@getfpsbit 4\relax
  \ifodd \@tempcnta
    \@flsetnum \@botnum
    \ifnum \@botnum>\z@
      \@tempswafalse
      \@flcheckspace \@botroom \@botlist
      \if@tempswa
        \global \maxdepth \z@
        \@flupdates \@botnum \@botroom \@botlist
        \@inserttrue
  \global\floatatbottrue
      \fi
    \fi
  \fi}

\let\p@wold@output\@outputpage
\renewcommand*{\@outputpage}{%
  \p@wold@output
  \global\floatattopfalse
  \global\floatatbotfalse}

\endinput
\end{lcode}
% \cs{floatattop} is probably set \ptrue\ if there is a float at the
% top of the page and
% \cs{floatatbot} is probably set \ptrue\ if there is a float at the bottom
% of the page.
만약 떠다니는 개체가 페이지의 꼭대기에 있다면 \cs{floatattop}은 아마도 \ptrue로
설정될 것이고 떠다니는 개체가 페이지의 바닥에 있다면 \cs{floatatbot}은 아마도
\ptrue로 설정될 것이다.


% \index{float!page|)}
% \index{pagestyle!float pages|)}
\tidx{float!page|),떠다니는!페이지|)}
\tidx{pagestyle!float pages|),페이지 양식!떠다니는 페이지|)}

% \section{The showlocs pagestyle}
\section{showlocs 페이지 양식}

%     The \pstyle{showlocs} pagestyle is somewhat special as it is meant to be
% used as an aid when designing a page layout. Lines are drawn showing the
% vertical positions of the headers and footers and a box is drawn around
% the textblock. It is implemented using two
% zero-sized\index{zero-sized picture} pictures.\verbfootnote{A
% zero-sized picture starts off with \verb?begin{picture}(0,0)...?.}
\pstyle{showlocs} 페이지 양식은 다소 특수하다고 볼 수 있는데, 이는 페이지 판매김
설계를 돕기 위해 만들어졌기 때문이다.
머릿글과 바닥글의 세로 위치를 표시하기 위한 선이 그어지며, 본문 영역 주변으로
상자가 그려진다.
이는 크기가 영인 그림\tidx{zero-sized picture,크기가 영인 그림} 두 개를 통해
구현하였다.\verbfootnote{크기가 영인 그림은 \verb|begin{picture}(0,0)...|으로
시작된다.}

\begin{syntax}
\cmd{\framepichead} \\
\cmd{\framepictextfoot} \\
\cmd{\framepichook} \\
\cmd{\showheadfootlocoff} \\
\cmd{\showtextblockoff} \\
\end{syntax}
\glossary(framepichead)%
  {\cs{framepichead}}%
  {Used by the \Ppstyle{showlocs} pagestyle to draw a line at the header 
   location.}
\glossary(framepictextfoot)%
  {\cs{framepictextfoot}}%
  {Used by the \Ppstyle{showlocs} pagestyle to draw a box around the textblock
   and a line at the footer location.}
\glossary(framepichook)%
  {\cs{framepichook}}%
  {First thing called inside the zero width pictures provided by
    \cs{framepichead} and \cs{framepictextfoot}. Empty by default.}%
\glossary(showtextblockoff)%
  {\cs{showtextblockoff}}%
  {Prevents \cs{framepictextfoot} from drawing a box around the textblock.}
\glossary(showheadfootlocoff)%
  {\cs{showheadfootlocoff}}%
  {Prevents \cs{framepichead} and \cs{framepictextfoot} from drawing
   lines at the header and footer locations.}
%
% The macro \cmd{\framepichead} creates a zero-sized\index{zero-sized picture}
% picture that draws a line at the header location, and the macro
% \cmd{\framepictextfoot} creates a zero-sized\index{zero-sized picture}
% picture that draws a line at the footer location
% and also draws a box around the typeblock. Following the declaration
% \cmd{\showheadfootlocoff} the macros \cmd{\framepichead} and
% \cmd{\framepictextfoot} do not draw lines showing the header and footer
% locations. The declaration \cmd{\showtextblockoff} prevents
% \cmd{\framepictextfoot} from drawing a box around the textblock.
\cmd{\framepichead} 매크로는 머릿글 위치에 선을 그리는, 크기가 영인
그림\tidx{zero-sized picture,크기가 영인 그림}을 생성하며,
\cmd{\framepictextfoot} 매크로는 바닥글 위치에 선을 그리고 조판 영역 주위에
상자를 그리는, 크기가 영인 그림\tidx{zero-sized picture,크기가 영인 그림}을
생성한다.
매크로 \cmd{\framepichead}와 \cmd{\framepictextfoot}은,
\cmd{\showheadfootlocoff} 정의 후에는 머릿글과 바닥글 위치에 선을 그리지
않는다.
\cmd{\showtextblockoff}의 정의는 \cmd{\framepictextfoot}가 본문 영역 주변에
상자 그리는 것을 방지한다.

% In case you want to change the color of the \pstyle{showlocs}, simply do
만약 여러분이 \pstyle{showlocs}의 색상을 바꾸고 싶다면, 다음과 같이 간단히 할
수 있다.
\begin{lcode}
  \renewcommand\framepichook{\color{red}}
\end{lcode}



    If you generally want a box around the textblock you may want to create
your own pagestyle using \cmd{\framepictextfoot} and the \pstyle{showlocs}
code as a starting point, see \path{memoir.cls} for details.
만약 여러분이 본문 영역 주위에 상자를 추가하는 일반적인 방법이 필요하다면,
\cmd{\framepictextfoot}와 \pstyle{showlocs} 코드를 발판삼아 직접 페이지 양식을
만들어야 할 것인데, 자세한 내용은 \path{memoir.cls}를 참고하자.


% \section{Other things to do with page styles}
\section{페이지 양식으로 할 수 있는 다른 일들}
\label{sec:other-things-do}

% Back on \pref{ex:draft.pagestyle} we presented a way of adding some
% draft information. Here is a more advanced example of this.
이전에 \pref{ex:draft.pagestyle}에서 우리는 초고 정보를 추가하는 방법에 대해
살펴보았다.
여기에 더 자세한 예시가 나와 있다.

% One interesting use for page styles is to provide extra information
% below the footer. This might be some kind of copyright information. Or
% if your document is under version control with a system like
% Subversion, and you have all your chapter laying in seperate files,
% then why not add information at the start of very chapter, specifying
% who did the last change to this chapter at which time. See the
% \texttt{svn-multi} package (\cite{svn-multi}) and the Prac\TeX{}
% Journal article \cite{practex-2007-3-ms} by the same author. Then this
% information can be added to the start of every chapter using something
% like:
페이지 양식의 흥미로운 사용 중 하나는 바닥글 아래에 추가 정보를 제시하는
것이다.
저작권 정보와 같은 것이 될 수 있다.
혹은 여러분의 문서가 Subversion과 같은 시스템으로 버전 관리가 되고 있고, 모든
단원이 서로 분리된 파일에 담겨 있다면, 단원의 맨 앞에 누가 해당 단원을 언제
수정하였는지에 대한 정보를 추가할 수도 있다.
\texttt{svn-multi} 패키지(\cite{svn-multi})와 동일 저자의 Prac\TeX{} 저널의
논문\cite{practex-2007-3-ms}을 보라.
이 정보는 다음과 같이 매 단원의 시작에 더해질 수 있다.
\begin{lcode}
\usepackage[filehooks]{svn-multi}
\makeatletter
% remember to define a darkgray color
\newcommand\addRevisionData{%
  \begin{picture}(0,0)%
    \put(0,-10){%
      \tiny%
      \expandafter\@ifmtarg\expandafter{\svnfiledate}{}{%
        \textcolor{darkgray}{Chapter last updated 
          \svnfileyear/\svnfilemonth/\svnfileday
         \enspace \svnfilehour:\svnfileminute\ (revision \svnfilerev)}
     }%
    }%
  \end{picture}%
}
\makeatother
% chapter is normally an alias to the plain style, we want to change
% it, so make it a real pagestyle
\makepagestyle{chapter} 
\makeoddfoot{chapter}{\addRevisionData}{\thepage}{}
\makeevenfoot{chapter}{\addRevisionData}{\thepage}{}
\end{lcode}
